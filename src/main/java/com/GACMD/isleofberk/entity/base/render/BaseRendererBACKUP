package com.GACMD.isleofberk.common.entity.entities.base.render;

import com.mojang.blaze3d.vertex.PoseStack;
import com.mojang.blaze3d.vertex.VertexConsumer;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.MultiBufferSource;
import net.minecraft.client.renderer.RenderType;
import net.minecraft.client.renderer.entity.EntityRendererProvider;
import net.minecraft.world.entity.LivingEntity;
import org.jetbrains.annotations.Nullable;
import software.bernie.geckolib3.core.IAnimatable;
import software.bernie.geckolib3.geo.render.built.GeoModel;
import software.bernie.geckolib3.model.AnimatedGeoModel;
import software.bernie.geckolib3.renderers.geo.GeoEntityRenderer;

public class BaseRenderer<T extends LivingEntity & IAnimatable> extends GeoEntityRenderer<T>
{
    private float prevRotationY = 0;
    private float currentRotationY = 0;
    private float rotationToEaseY = 0;
    private float prevRotationX = 0;
    private float currentRotationX = 0;
    private float rotationToEaseX = 0;
    private int rotationCheckCoolDown = 0;

    protected BaseRenderer(EntityRendererProvider.Context renderManager, AnimatedGeoModel<T> modelProvider) {
        super(renderManager, modelProvider);
    }

    @Override
    public void render(GeoModel model, T animatable, float partialTicks, RenderType type, PoseStack matrixStackIn, @Nullable MultiBufferSource renderTypeBuffer, @Nullable VertexConsumer vertexBuilder, int packedLightIn, int packedOverlayIn, float red, float green, float blue, float alpha) {
        // We set the current rotation to the current Y rotation of the Entity body.
        currentRotationY = animatable.yBodyRot;

        currentRotationX = animatable.getXRot();
        // We call the method between the updates to current and previous rotation, so it gets the proper values.
        modifyAnimation(model, animatable, partialTicks, type, matrixStackIn, renderTypeBuffer, vertexBuilder, packedLightIn, packedOverlayIn, red, green, blue, alpha);
        // We set the previous rotation to the current one, as it's the end of the render tick, and current will be updated during the next.
        prevRotationY = currentRotationY;

        prevRotationX = currentRotationX;

        // Lastly we super the render method.
        super.render(model, animatable, partialTicks, type, matrixStackIn, renderTypeBuffer, vertexBuilder, packedLightIn, packedOverlayIn, red, green, blue, alpha);
    }

    /**
     * This method is used to modify the models of Entities. It gets called between the rotation values thus making it ideal for manipulations that require rotation updates.
     */
    protected void modifyAnimation(GeoModel model, T animatable, float partialTicks, RenderType type, PoseStack matrixStackIn, @Nullable MultiBufferSource renderTypeBuffer, @Nullable VertexConsumer vertexBuilder, int packedLightIn, int packedOverlayIn, float red, float green, float blue, float alpha) {
        if(model.getBone("Tail1").isPresent()) {
            float boneY1 = model.getBone("Tail1").get().getRotationY();
            float boneY2 = model.getBone("Tail2").get().getRotationZ();
            float boneY3 = model.getBone("Tail3").get().getRotationZ();
            float boneY4 = model.getBone("Tail4").get().getRotationZ();
            float boneY5 = model.getBone("Tail5").get().getRotationZ();

            float boneX1 = model.getBone("Tail1").get().getRotationX();
            float boneX2 = model.getBone("Tail2").get().getRotationX();
            float boneX3 = model.getBone("Tail3").get().getRotationX();
            float boneX4 = model.getBone("Tail4").get().getRotationX();
            float boneX5 = model.getBone("Tail5").get().getRotationX();

            // TODO probably separate the "rotationCheckCoolDown" into 2 different ones so the tail can ease back on the Y axis even though the Dragon may be rotating on the X Axis!
            // TODO take into consideration partial ticks, to make the easing smooth and nice!
            // TODO properly check if all bones are present, to avoid null pointers!
            if(!Minecraft.getInstance().isPaused()) { // TODO make sure this works fine on servers as the game is technically not paused!
                // We get the amount the tail should be moved to the left or right.
                rotationToEaseY = clamp(rotationToEaseY += (currentRotationY - prevRotationY), -12, 12);

                rotationToEaseX = clamp(rotationToEaseX += -(currentRotationX - prevRotationX), -6, 15);

                // If the Dragon is rotating we set the tick cool down for the revert easing to value "X"
                if(isDragonRotating())
                    rotationCheckCoolDown = 3;

                if(prevRotationX != currentRotationX)
                    rotationCheckCoolDown = 3;

                // If the dragon isn't rotating and the revert easing cool down is 0 we start reducing the tails rotation modifier.
                if(!isDragonRotating() && (rotationCheckCoolDown == 0))
                    rotationToEaseY -= rotationToEaseY / 20;

                if(prevRotationX == currentRotationX && (rotationCheckCoolDown == 0))
                    rotationToEaseX -= rotationToEaseX / 20;

                // If the cool down is greater than 0 we have to start reducing it.
                if(rotationCheckCoolDown > 0)
                    rotationCheckCoolDown--;

                boneY1 += Math.toRadians(rotationToEaseY);
                boneY2 += Math.toRadians(rotationToEaseY);
                boneY3 += Math.toRadians(rotationToEaseY);
                boneY4 += Math.toRadians(rotationToEaseY);
                boneY5 += Math.toRadians(rotationToEaseY);

                boneX1 += Math.toRadians(rotationToEaseX);
                boneX2 += Math.toRadians(rotationToEaseX);
                boneX3 += Math.toRadians(rotationToEaseX);
                boneX4 += Math.toRadians(rotationToEaseX);
                boneX5 += Math.toRadians(rotationToEaseX);
            }
            model.getBone("Tail1").get().setRotationY(boneY1);
            model.getBone("Tail2").get().setRotationZ(boneY2);
            model.getBone("Tail3").get().setRotationZ(boneY3);
            model.getBone("Tail4").get().setRotationZ(boneY4);
            model.getBone("Tail5").get().setRotationZ(boneY5);

            model.getBone("Tail1").get().setRotationX(boneX1);
            model.getBone("Tail2").get().setRotationX(boneX2);
            model.getBone("Tail3").get().setRotationX(boneX3);
            model.getBone("Tail4").get().setRotationX(boneX4);
            model.getBone("Tail5").get().setRotationX(boneX5);
        }
    }

    /**
     * Checks the previous tick Rotation and compares it to the current tick Rotation to determine id the dragon has rotated.
     * @return Whether the Dragon has rotated this tick.
     */
    private boolean isDragonRotating()
    {
        return this.prevRotationY != this.currentRotationY;
    }

    /**
     * Used to clamp a given value between a Minimum and Maximum value.
     * @param val The given Value to be clamped.
     * @param min The Minimum value the given value should have.
     * @param max The Maximum value the given value should have.
     * @return A Value based on the given Value, while ensuring its fitting the Minimum to Maximum range.
     */
    private float clamp(float val, float min, float max)
    {
        return Math.max(min, Math.min(max, val));
    }
}